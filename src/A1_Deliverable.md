---
layout: layout/mylayout.ejs
title: Assignment 1B
---

<style>
    .content-container { margin: 0 auto; max-width: 8.5in; padding: 20px; text-align: justify;} 
    .content-container p { margin-bottom: 15px;} 
    .content-container h3 { text-align: center; margin-bottom: 20px; } 
</style>

<div class="content-container">

<h2 class="text-center">Assignment Report</h2>

#### Overview & Key Features
In this lab, I undertook the task of transitioning my website from Nunjucks to EJS, which involved several key activities 
aimed at improving the overall functionality and structure of my site. I created a `JSON` file to hold all the data for the 
blog section, encompassing essential information such as titles, descriptions, and images. The entire website, originally 
built using Eleventy (11ty) and Nunjucks, underwent a complete conversion to EJS, leveraging `Express.js` for server-side 
routing and rendering. In addition to this conversion, I developed several new pages to enhance user experience, including 
a custom `404.ejs` error page, a `TOC.ejs` (Terms and Conditions) page generated by Termly, a `markdownPage.ejs` template for 
rendering Markdown content, an `about.ejs` static page about the site or author, and a `pagination.ejs` partial template for 
pagination functionality across multiple blog posts.

To facilitate these updates, I established a server API called `server.js`, essential for managing routing dictated by
Express.js and EJS. This server setup allowed for effective management of page requests, error handling, and data rendering.
Working with JSON data was straightforward, thanks to my previous experience with React and Nunjucks, which made the
transition smoother. The primary challenge involved handling escape characters that differ slightly based on the templating
engine. Nevertheless, manipulating JSON data for my blog section was relatively simple. While paging is typically
straightforward, its implementation proved more challenging than anticipated. After several hours, I decided to use a
Node.js pagination library, which significantly simplified the process. By integrating this library with EJS, I effectively
implemented pagination, allowing users to navigate through multiple blog posts easily.

For my choice of templating engine, I selected EJS (Embedded JavaScript) for two main reasons. First, my hands-on
experience with EJS from my Web Development Client-Side Scripting class made me comfortable using it for this project.
Second, EJS offers more granular control and flexibility compared to Nunjucks, which abstracts many inner workings.
This level of control was appealing, as I wanted to manage data rendering and HTML structure directly. EJS provided
a balance of flexibility and ease of use that aligned perfectly with my goals for the site, making it the obvious choice
for this project.

The front end is primarily built using EJS templates, Bootstrap, and standard JavaScript. EJS dynamically generates
HTML by embedding JavaScript code, allowing for the rendering of backend data directly into the views. For instance,
the blog section pulls data from a JSON file and displays it dynamically using a loop in EJS. Bootstrap is employed
for styling and ensuring responsiveness, with its grid system adjusting the application to different screen sizes
(still working on the images and their sizing) to provide a user-friendly experience across devices. JavaScript handles
dynamic client-side behavior, such as interactive header components, creating dynamic content while keeping the page
'static.' Together, these front-end technologies deliver a dynamic and visually appealing user interface, driven by
server-rendered content.

The backend is constructed using Node.js and Express.js, with Express handling application routing. It defines routes
that connect client requests (e.g., `/`, `/blog`, `/contact`) to the appropriate controllers or views and serves static files
like CSS, JavaScript, and images. Controllers contain the logic for handling requests; for instance, when a user visits
the blog page, the controller fetches necessary data from the JSON file and passes it to the EJS template for rendering.
Typically, controllers for static pages are housed in separate files, but I have kept them together to ensure proper
functionality and organization within the codebase. Overall, the backend acts as the brain of the application, processing
user requests, interacting with JSON and the server API, and serving the correct views.

To reduce repetition in the project codebase, I use partial files in EJS, which allow for code reuse by breaking down
common sections of the website into separate templates. The header partial includes the navigation bar and dynamic page
title and is included at the top of each page. The footer partial contains copyright information and relevant links,
included at the bottom of every page. I also have a partial for pagination, which uses JavaScript, EJS, and Bootstrap
to create an aesthetic and functional paging system for my blog. This approach makes it easier to maintain the web app
because changes to the header, footer, or other repeated sections need to be made in only one place, reflecting
automatically across all pages.

In summary, this lab focused on converting a site from Nunjucks to EJS, creating new pages, setting up server routing,
and working with JSON data and pagination. The entire experience significantly solidified my understanding of server-side
rendering and provided me with hands-on experience with Express.js and EJS in a real-world context.

</div>
